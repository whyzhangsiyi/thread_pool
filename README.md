# [线程池项目]()

环境：**vs2019**开发，**C++17**标准；**centos7**编译**so**动态库

## [项目介绍]()


作为五大池之一（内存池、连接池、线程池、进程池、协程池），线程池的应用非常广泛，不管是客户端程序，还是后台服务程序，都是提高业务处理能力的必备模块。
## [知识背景]()

熟练基于**C++ 11**标准的面向对象编程

组合和继承、继承多态、**STL**容器、智能指针、函数对象、绑定器、可变参模板编程等。熟悉**C++11**多线程编程

thread**、**mutex**、**atomic**、**condition_variable**、**unique_lock**等。** C++17**和**C++20**标准的内容**

C++17**的**any**类型和**C++20**的信号量**semaphore**，项目上都我们自己用代码实现。熟悉多线程理论**

多线程基本知识、线程互斥、线程同步、原子操作、**CAS**等。

## [项目代码片段]()
<img width="1035" alt="image" src="https://github.com/whyzhangsiyi/thread_pool/assets/103186652/3a96f454-579c-4bc4-aeec-d8617f256a72">


## [并发和并行]()
CPU**单核**

CPU**多核、多**CPU

### [并发]()

单核上，多个线程占用不同的**CPU**时间片，物理上还是串行执行的，但是由于每个线程占用的**CPU**时间片非常短（比如**10ms**），看起来就像是多个线程都在共同执行一样，这样的场景称作并发

（**concurrent**）。

### [并行]()

在多核或者多**CPU**上，多个线程是在真正的同时执行，这样的场景称作并行（**parallel**）。

## [多线程的优势]()


多线程程序一定就好吗？不一定，要看具体的应用场景：

[IO]()密集型

无论是**CPU**单核、**CPU**多核、多**CPU**，都是比较适合多线程程序的

[CPU]()密集型

CPU**单核**

多线程存在上下文切换，是额外的花销，线程越多上下文切换所花费的额外时间也越多，倒不如一个线程一直进

行计算。

CPU**多核、多**CPU

多个线程可以并行执行，对**CPU**利用率好。

## [线程池]()

### [线程的消耗]()
线程的创建和销毁都是非常**"**重**"**的操作,需要中断到内核

线程栈本身占用大量内存

线程的上下文切换要占用大量时间

大量线程同时唤醒会使系统经常出现锯齿状负载或者瞬间负载量很大导致宕机

### [线程池的优势]()

操作系统上创建线程和销毁线程都是很**"**重**"**的操作，耗时耗性能都比较多，那么在服务执行的过程中，如果业务量比较大，实时的去创建线程、执行业务、业务完成后销毁线程，那么会导致系统的实时性能降低，业务的处理能力也会降低。

线程池的优势就是（每个池都有自己的优势），在服务进程启动之初，就事先创建好线程池里面的线程，当业务流量到来时需要分配线程，直接从线程池中获取一个空闲线程执行**task**任务即可，**task**执行完成后，也不用释放线程，而是把线程归还到线程池中继续给后续的**task**提供服务。

#### [ﬁxed]()模式线程池

线程池里面的线程个数是固定不变的，一般是**ThreadPool**创建时根据当前机器的**CPU**核心数量进行指定。

#### [cached]()模式线程池

线程池里面的线程个数是可动态增长的，根据任务的数量动态的增加线程的数量，但是会设置一个线程数量的阈值（线程过多的坏处上面已经讲过了），任务处理完成，如果动态增长的线程空闲了**60s**还没有处理其它任务，那么关闭线程，保持池中最初数量的线程即可。

## [线程同步]()

### [线程互斥]()

互斥锁**mutex atomic**原子类型

### [线程通信]()

条件变量 **condition_variable**

信号量 **semaphore**

## [项目设计]()

<img width="1314" alt="image" src="https://github.com/whyzhangsiyi/thread_pool/assets/103186652/1a09e2b1-a0af-4484-a25c-37c3ea996416">


高并发网络服务器 **master-slave**线程模型耗时任务处理
项目名称：基于可变参模板实现的线程池


平台工具：**vs2019**开发，**centos7 g++**编译**so**库，**gdb**调试分析定位死锁问题

项目描述：

1**、基于可变参模板编程和引用折叠原理，实现线程池**submitTask**接口，支持任意任务函数和任意参数的传递**

2**、使用**future**类型定制**submitTask**提交任务的返回值** 3**、使用**map**和**queue**容器管理线程对象和任务**

4**、基于条件变量**condition_variable**和互斥锁**mutex**实现任务提交线程和任务执行线程间的通信机制** 5**、支持**ﬁxed**和**cached**模式的线程池定制**


项目问题：

1**、在**ThreadPool**的资源回收，等待线程池所有线程退出时，发生死锁问题，导致进程无法退出**

2**、在**windows**平台下运行良好的线程池，在**linux**平台下运行发生死锁问题，平台运行结果有差异化**

分析定位问题：

主要通过**gdb attach**到正在运行的进程，通过**info threads**，**thread tid**，**bt**等命令查看各个线程的调用堆栈信息，结合项目代码，定位到发生死锁的代码片段，分析死锁问题发生的原因.
