
环境： vs2019开发， C++17标准； centos7编译so动态库
  基于C++ 11标准的面向对象编程
组合和继承、继承多态、  STL容器、智能指针、函数对象、绑定器、可变参模板编程等。
  熟悉C++11多线程编程
thread、 mutex、atomic、condition_variable、unique_lock等。
   C++17和C++20标准的内容
C++17的any类型和C++20的信号量semaphore 
  熟悉多线程理论
多线程基本知识、线程互斥、线程同步、原子操作、  CAS等。
项目代码片段


![image](https://github.com/whyzhangsiyi/thread_pool/assets/103186652/85e5198c-f21f-4262-bbd2-4305ca8ea635)


并发和并行

·CPU 单核
·CPU 多核、多CPU
并发
单核上，多个线程占用不同的CPU 时间片，物理上还是串行执行的，但是由于每个线程占用的CPU 时间
片非常短(比如10ms),    看起来就像是多个线程都在共同执行一样，这样的场景称作并发 (concurrent)。
并行
在多核或者多CPU上，多个线程是在真正的同时执行，这样的场景称作并行 (parallel)。


多线程的优势

多线程程序一定就好吗?不一定，要看具体的应用场景：
I0密集型
无论是CPU 单核、CPU 多核、多CPU, 都是比较适合多线程程序的
CPU密集型
·CPU 单核
多线程存在上下文切换，是额外的花销，线程越多上下文切换所花费的额外时间也越多
·CPU 多核、多CPU
多个线程可以并行执行，对CPU 利用率好。

线程池

线程的消耗
  线程的创建和销毁都是非常"重"的操作
  线程栈本身占用大量内存
  线程的上下文切换要占用大量时间
  大量线程同时唤醒会使系统经常出现锯齿状负载或者瞬间负载量很大导致宕机
线程池的优势
操作系统上创建线程和销毁线程都是很"重"的操作，耗时耗性能都比较多，那么在服务执行的过程中，
如果业务量比较大，实时的去创建线程、执行业务、业务完成后销毁线程，那么会导致系统的实时性能 降低，业务的处理能力也会降低。
线程池的优势就是（每个池都有自己的优势），在服务进程启动之初，就事先创建好线程池里面的线程，当业务流量到来时需要分配线程，直接从线程池中获取一个空闲线程执行task任务即可，  task执行 完成后，也不用释放线程，而是把线程归还到线程池中继续给后续的task提供服务。
ﬁxed模式线程池
线程池里面的线程个数是固定不变的，  一般是ThreadPool创建时根据当前机器的CPU核心数量进行指 定。
cached模式线程池
线程池里面的线程个数是可动态增长的，根据任务的数量动态的增加线程的数量，但是会设置一个线程 数量的阈值，任务处理完成，如果动态增长的线程空闲了60s还没  有处理其它任务，那么关闭线程，保持池中最初数量的线程即可。	

线程同步	
线程互斥
   互斥锁mutex
   atomic原子类型
线程通信
  条件变量 condition_variable
  信号量 semaphore


项目设计	

![image](https://github.com/whyzhangsiyi/thread_pool/assets/103186652/20d85723-cce6-4780-a605-a98c23e48bca)


ThreadPool线程池



项目问题：
1、在ThreadPool的资源回收，等待线程池所有线程退出时，发生死锁问题，导致进程无法退出
2、在windows 平台下运行良好的线程池，在linux平台下运行发生死锁问题，平台运行结果有差异化
分析定位问题：

主要通过gdb attach到正在运行的进程，通过info threads ，thread tid ， bt等命令查看各个线程的调用 堆栈信息，结合项目代码，定位到发生死锁的代码片段，分析死锁问题发生的原因,以及最终的 解决方案。
